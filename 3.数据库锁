  乐观锁和悲观锁看名称挺高大上的，面试的时候一些面试官最喜欢拿这个来考应聘者。这个也是有意义的，一个PHP程序员如果没有接触过乐观锁和非观锁，那么他根本没有
接触过像样的业务了。

注意：事物提交时，释放锁

1.悲观锁（for update）
    什么是悲观锁？看意思就是比较，不相信其它的人不会改，所以查询的时候就加锁，然后自己更新数据再释放锁。可以有效防止减库存冲突问题。
    
    实验：
    １.首先有一张表，假如是user表，存在字段，id,name,money
    2.启动（A,B）两个终端，全部关闭自动提交，set autocommit=0;
    3.在A终端中，输入，select * from user where id=1 for update;
    4.在B终端，输入，select * from user where id=1 for update;此时，你会发现，B终端被Block了
    ５.在A终端输入，update user set money=money+1 where id=1;然后提交　commit;
    6.在B终端，你会发现，Block消失，并显示阻塞时间
    ７.实验结束
    
    这是就是悲观锁的使用案例
    
2.乐观锁（数据库默认不提供，需要自己实现）
　　什么是乐观锁？相反就是认为没几个人用，基本不会碰到有人修改，所以查询时就不加锁，然后更新的时候判断一下数据是不是被改掉。
    
    使用步骤：
    --开始事务
    1.查询商品信息
    2.判断商品库存是否大于购买数据
    3.如果库存满足，减少商品表库存（条件是商品表的库存=1步骤中查询出的库存）
    比如：update product set store = store - {$count} where store = {$product->store}  ($product->store为1步骤查询得到的库存)
    ４.减少商品SKU表库存（同样需要判断条件）
    ５.记录订单操作记录等
    --事务提交（事务提交时即释放锁）。
    可以看到乐观锁整个过程中实际并未执行任何加锁，我也不知道为什么会有这样的称呼。实际它是一种判断冲突的有效手段。
    在上面的乐观锁的执行流程中，如果3、4、5这三步中的任何一步发生异常，都会因滚事务。这样就不会出现减库存冲突导致库存脏数据了。
    －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
    在使用乐观锁时，要考虑进一步，就是在乐观锁时如果发现数据被修改，更新失败时，要考虑再重新获取数据，重新判断重新更新。
    这样就不会因为更新失败导致此笔业务失败，而相当于把它立即加进到下一步的队列而在同步请求中即能得到解决
  
３.总结：
    两种锁各有各的好，建议电商网站起步时访问量不大，不会造成压力时使用悲观锁。因为这时没有什么高并发，但也要好好检查代码防止出现死锁。
    对于成熟的电商网站，必须面对高并发的情况下，应该使用乐观锁。
    
    
    
